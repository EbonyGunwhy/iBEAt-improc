"""Editing of masks, or replacement of automasks by edited masks"""

import os
import logging
import numpy as np
import napari
import dbdicom as db

from utils import data


#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#!!!!!!!!!!!!!!!!!!! DANGER ZONE !!!!!!!!!!!!!!!!!!!!!!
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

SITE = 'Bari'
# OUTPUT_PATH = os.path.join(os.getcwd(), 'build')
OUTPUT_PATH = 'G:\Shared drives\iBEAt-build'


#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#!!!!!!!!!!!!!!!!!!!!! END !!!!!!!!!!!!!!!!!!!!!!!!!!!!
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!




INPUT_PATH = 'G:\Shared drives\iBEAt-build'
datapath = os.path.join(INPUT_PATH, 'dixon_2_data')
maskpath = os.path.join(INPUT_PATH, 'kidneyvol_1_segment')
editpath = os.path.join(OUTPUT_PATH, 'kidneyvol_3_edit')
os.makedirs(editpath, exist_ok=True)


# Set up logging
logging.basicConfig(
    filename=os.path.join(editpath, 'error.log'),
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)

# # Cases that need editing
# EDIT = [
#     '1128_002',
#     '1128_003',
# ]


def edit_mask_with_napari(image_3d: np.ndarray, mask_3d: np.ndarray) -> np.ndarray:
    """
    Launches Napari to manually edit a 3D mask over a 3D image.

    Parameters:
    - image_3d: numpy.ndarray
        A 3D image array (shape: Z, Y, X)
    - mask_3d: numpy.ndarray
        A 3D mask array (shape: Z, Y, X)

    Returns:
    - edited_mask: numpy.ndarray
        The modified mask after editing in Napari.
    """
    if image_3d.shape != mask_3d.shape:
        raise ValueError("Image and mask must have the same shape.")
    
    # Ensure label image is integer type
    mask_3d = mask_3d.astype(np.int32)

    # Launch Napari
    viewer = napari.Viewer()

    # Display the image and the mask
    viewer.add_image(image_3d, name='Image')
    mask_layer = viewer.add_labels(mask_3d, name='Mask')

    # Set 2D slicing and coronal orientation for (X, Y, Z) image
    viewer.dims.ndisplay = 2
    viewer.dims.order = [2, 1, 0]  # Y, Z, X order for coronal view

    print("Edit the mask. Close the Napari window to return the edited mask.")

    # Run Napari event loop
    napari.run()

    # Return the edited mask
    return mask_layer.data


def edit_auto_masks(site):

    sitedatapath = os.path.join(datapath, site, "Patients") 
    sitemaskpath = os.path.join(maskpath, site, "Patients")
    siteeditpath = os.path.join(editpath, site, "Patients")

    # List of selected dixon series
    record = data.dixon_record()

    # Loop over the autogenerated masks
    for mask_series in db.series(sitemaskpath):

        # Patient and output study
        patient = mask_series[1]
        study = mask_series[2][0]
        
        # # Skip those that don't need editing
        # if patient not in EDIT:
        #     continue

        # Skip if the edited masks already exist
        edited_mask_study = [siteeditpath, patient, (study, 0)]
        edited_mask_series = edited_mask_study + [(f'kidney_masks', 0)]
        if edited_mask_series in db.series(edited_mask_study):
            continue

        # Get the out-phase sequence
        sequence = data.dixon_series_desc(record, patient, study)
        series_op = [sitedatapath, patient, study, sequence + '_out_phase']
        op = db.volume(series_op)

        # Get the auto-mask
        auto_mask_series = [sitemaskpath, patient, study, f'kidney_masks']
        auto_mask = db.volume(auto_mask_series)

        # Edit the mask and save
        try:
            edited_mask = edit_mask_with_napari(op.values, auto_mask.values)
        except Exception as e:
            logging.error(f"{patient} {study} error editing mask: {e}")
        else:
            vol = (edited_mask.astype(np.int16), auto_mask.affine)
            db.write_volume(vol, edited_mask_series, ref=series_op)


def all():
    edit_auto_masks('Bari')
    edit_auto_masks('Leeds')
    edit_auto_masks('Sheffield')


if __name__=='__main__':
    edit_auto_masks(SITE)
